# Introducción

Nuestro primer paso será trabajar con el archivo **logins.json** de Firefox, donde se almacenan las credenciales de los usuarios de manera cifrada. Aprenderemos a localizar y acceder a este archivo, entenderemos su estructura y, cómo es que, podremos descifrar estas credenciales para obtener esta información en texto claro. 

Después de extraer las credenciales, lo siguiente será utilizar nuestra función para enviárnoslas por correo, garantizando que las credenciales se trasmitan de forma garantizada y segura a nosotros como atacantes. 

Finalmente, utilizando **PyInstaller** convertiremos nuestro script a una aplicación ejecutable **.exe**, lo cual es crucial para asegurarnos de que nuestro programa funcione en sistemas Windows. Además, nuestro programa no será detectado por Windows defender, lo que demuestra una aplicacion practica de como se pueden disenar programas maliciosos para pasar inadvertidos por las medidas de seguridad estandar.

# Práctica

Si nosotros nos vamos a nuestro gestor de archivos y en este nos vamos a nuestro directorio base de usuario, aquí podremos acceder a las carpetas **AppData -> Roaming -> Mozilla -> Firefox -> Profiles**, aquí tendremos que enfocarnos en aquella carpeta que tenga **release** en su nombre, en este caso la primera:

![[Offensive/Malware/images/010.PNG]]

Dentro de esta carpeta tendremos el archivo **logins.json**, pero si lo abrimos en nuestro bloc de notas veremos cómo el contenido de las credenciales se encuentra cifrado:

![[Offensive/Malware/images/011.PNG]]

Parecen tener un formato de **base64**, pero si se descifra esto, por detrás tiene otro tipo de cifrado. Aquí es donde entra en juego el empleo de una herramienta, la cual es **fiefox_decrypt.py**, la cual es una herramienta que tiene su propio [repositorio](https://github.com/unode/firefox_decrypt). 

Lo que buscaremos será con nuestro script traernos el propio script **[firefox_decrypt.py](https://raw.githubusercontent.com/unode/firefox_decrypt/refs/heads/main/firefox_decrypt.py)** de esta herramienta. Este si lo ejecutamos bastaría con pasarle la ruta de nuestro **release** del navegador Firefox que acabamos de ver anteriormente, que es donde se encuentra el archivo **logins.json** y esto por detrás el script lo utilizara, así como otros archivos del mismo directorio para llegar a descifrar las contraseñas almacenadas y será lo que nos retornara al ejecutarlo. 

Por ello, aprovechando parte del script que ya teníamos, vamos a eliminar únicamente la parte del código que nos traía el archivo lazagne y lo adaptaremos para traer y almacenar el script del **firefox_decrypt**:

![[Offensive/Malware/images/012.PNG]]

A cómo tenemos el script, esto nos descargará el archivo de Python del Firefox decrypt y lo almacenará en un directorio temporal y nos imprimirá donde se encuentra este directorio. 

Si después nosotros accedemos manualmente, veremos como ya tenemos el archivo y si lo abrimos veremos perfectamente que es el script:

![[Offensive/Malware/images/013.PNG]]

![[Offensive/Malware/images/014.PNG]]

En lo anterior, hacemos ejecución del comando whoami para recuperar el nombre del usuario, como este comando nos retornara un formato 'HOST\Username', hacemos un split para quedarnos únicamente con el nombre de usuario y en el split ignoramos la propia barra para que no nos lo tome como el carácter especial para saltar caracteres. 

En la variable **path** estamos almacenando la ruta completa de los profiles de Firefox, aquí nos falta aún obtener la carpeta que contiene **relase** en su nombre. En este caso escapamos las propias barras debido a que si no lo hacemos, estas las podrían detectar como cuando vamos a colocar caracteres especiales o saltar algún carácter.

Para los profiles listamos el propio directorio y justamente aquella carpeta que tenga **release** en su nombre la vamos a tomar y, como esto será una lista, se toma el primer elemento y se retorna la ruta completa. 

Si esto nos da error, es porque nuestra función al ejecutar el comando probablemente nos retorne el output con un salto de línea, por ello bastará con aplicarle un **strip()** al retornar el output para eliminar estos caracteres a los lados.

Finalmente, como ya tenemos el archivo ejecutable y la ruta completa de donde se encuentra nuestro archivo **logins.json**, bastará con ejecutar el script de nuestro firefox_decrypt y pasarle la ruta:

![[Offensive/Malware/images/015.PNG]]

En nuestra función para la ejecución del comando agregaremos un **try**. Esto lo utilizaremos para evitar problemas de cara a errores que puedan darse. Si se nos da un error, colocaremos el error y solo retornaremos el output con el decode y el strip. Nuestro output tiene contenido:

![[Offensive/Malware/images/016.PNG]]

Si llegamos a tener problemas con la ejecución del comando, ejecutaremos el comando con **subprocess.run** y, en el caso de que tenga espacios, todo será separado en una lista:

![[Offensive/Malware/images/017.PNG]]

De esta manera, al ejecutar el comando evitamos errores al utilizar algo más moderno como **run**, que en este caso requiere del comando en un formato de lista, tanto **whoami** como el script. Si con ello corremos nuestro programa con Windows defender corriendo, no tendremos problemas y ahora listaremos las credenciales almacenadas en Firefox:

![[Offensive/Malware/images/018.PNG]]

Con ello ya finalmente podremos enviarnos el output por correo:

![[Offensive/Malware/images/019.PNG]]

![[Offensive/Malware/images/020.PNG]]

Con todo esto listo, finalmente nos faltaría transformar nuestro script a un ejecutable. Para ello instalaríamos en la terminal **pyinstalles** utilizando **pip**. Finalmente, ejecutaríamos:

```python
PyInstaller --onefile malware.py
```

Si no funciona:

```python
python -m PyInstaller --onefile malware.py
```

En este caso yo tengo el **Malware.py** en el escritorio, por lo que al ejecutar aquí el comando me dejara varios outputs, uno de ellos será la carpeta dist que nos dejara un ejecutable y ya si este lo ejecutamos estaría corriendo nuestro malware que ahora es un ejecutable **.exe**, este ya corre sin necesidad de Python en la máquina víctima y además contiene las librerías necesarias en el.

## Siguientes apuntes

[[Creación de Backdoors y Command and Control (C&C) (1-2)]]
